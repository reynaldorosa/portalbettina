import { useState, useEffect, useCallback } from 'react'
import databaseService from '../database/core/DatabaseService.js'

export const calculateScore = (successes, attempts) => {
  return successes * 10 - attempts * 2
}

export const updateProgress = (successes, attempts) => {
  const score = calculateScore(successes, attempts)
  return { successes, attempts, score }
}

const useProgress = (activityId) => {
  const [progress, setProgress] = useState({
    score: 0,
    attempts: 0,
    successes: 0,
    accuracy: 0,
    timeSpent: 0,
    level: 1,
    stars: 0,
  })

  const [isCompleted, setIsCompleted] = useState(false)
  const [startTime, setStartTime] = useState(null)
  const [activityStartTime, setActivityStartTime] = useState(null)
  const [pauseStartTime, setPauseStartTime] = useState(null)
  const [totalPausedTime, setTotalPausedTime] = useState(0)
  const [sessionId, setSessionId] = useState(null)
  const [timeUpdateInterval, setTimeUpdateInterval] = useState(null)
  const [userId, setUserId] = useState(null)

  // Carregar ID do usu√°rio do localStorage
  useEffect(() => {
    const storedId = localStorage.getItem('betina_user_id')
    if (storedId) {
      setUserId(storedId)
    }
  }, []) // Carregar progresso do banco de dados
  useEffect(() => {
    if (activityId && userId) {
      const loadProgress = async () => {
        try {
          const sessions = await databaseService.getGameSessions(userId, activityId, 1)
          if (sessions && sessions.length > 0) {
            const latestSession = sessions[0]
            const progressData = {
              score: latestSession.score || 0,
              attempts: latestSession.total_attempts || 0,
              successes: latestSession.correct_answers || 0,
              timeSpent: latestSession.time_spent || 0,
              level: latestSession.data?.level || 1,
              stars: latestSession.data?.stars || 0,
              difficulty: latestSession.difficulty || 'MEDIUM',
            }
            console.log('Progresso carregado do banco de dados:', progressData)
            setProgress(progressData)
          } else {
            // Se n√£o h√° sess√µes, usar valores padr√£o
            console.log('Nenhuma sess√£o encontrada no banco de dados, usando valores padr√£o')
          }
        } catch (error) {
          console.warn('Erro ao carregar progresso do banco de dados:', error.message)
        }

        setStartTime(Date.now())
      }

      loadProgress()
    }
  }, [activityId, userId]) // Salvar progresso no banco de dados
  const saveProgress = useCallback(
    async (newProgress) => {
      if (activityId && userId) {
        const progressToSave = {
          ...progress,
          ...newProgress,
          lastPlayed: new Date().toISOString(),
        }

        // ‚úÖ Atualizar estado local IMEDIATAMENTE para reatividade da UI
        setProgress(progressToSave)

        // Salvar no banco de dados
        try {
          const timeSpent = startTime ? Math.floor((Date.now() - startTime) / 1000) : 0
          const accuracy =
            progressToSave.attempts > 0
              ? Math.min(
                  100,
                  Math.round((progressToSave.successes / progressToSave.attempts) * 100)
                )
              : 0

          await databaseService.saveGameSession({
            user_id: userId,
            game_id: activityId,
            difficulty: progressToSave.difficulty || 'MEDIUM',
            score: progressToSave.score || 0,
            accuracy,
            time_spent: timeSpent,
            completed: isCompleted,
            correct_answers: progressToSave.successes || 0,
            total_attempts: progressToSave.attempts || 0,
            data: {
              level: progressToSave.level || 1,
              stars: progressToSave.stars || 0,
              ...newProgress,
            },
          })
          console.log('Progresso salvo no banco de dados com sucesso')
        } catch (error) {
          console.error('Erro ao salvar progresso no banco de dados:', error.message)
        }
      }
    },
    [activityId, progress, userId, startTime, isCompleted]
  )
  // Incrementar sucessos
  const incrementSuccesses = useCallback(() => {
    const newSuccesses = progress.successes + 1
    saveProgress({ successes: newSuccesses })
  }, [progress.successes, saveProgress])

  // Completar atividade
  const completeActivity = useCallback(() => {
    setIsCompleted(true)
    const timeSpent = startTime ? Math.floor((Date.now() - startTime) / 1000) : 0
    saveProgress({ timeSpent, completed: true })
  }, [startTime, saveProgress])

  // Atualizar pontua√ß√£o
  const updateScore = useCallback(
    (newScore) => {
      saveProgress({ score: newScore })
    },
    [saveProgress]
  )

  // Atualizar n√≠vel
  const updateLevel = useCallback(
    (newLevel) => {
      saveProgress({ level: newLevel })
    },
    [saveProgress]
  )

  // Incrementar tentativas
  const incrementAttempts = useCallback(() => {
    const newAttempts = progress.attempts + 1
    saveProgress({ attempts: newAttempts })
  }, [progress.attempts, saveProgress]) // Registrar sucesso
  const recordSuccess = useCallback(
    (additionalPoints = 0) => {
      const newSuccesses = progress.successes + 1
      const newAttempts = progress.attempts + 1
      // Adicionar pontos base (10) mais quaisquer pontos adicionais por b√¥nus
      const newScore = progress.score + 10 + additionalPoints
      const accuracy = Math.round((newSuccesses / newAttempts) * 100)

      let stars = 0
      if (accuracy >= 90) stars = 3
      else if (accuracy >= 70) stars = 2
      else if (accuracy >= 50) stars = 1

      const newProgress = {
        successes: newSuccesses,
        attempts: newAttempts,
        score: newScore,
        accuracy: accuracy,
        stars,
      }

      // Atualizar estado local imediatamente para reatividade da UI
      setProgress((prev) => ({
        ...prev,
        ...newProgress,
      }))

      // Salvar no banco/localStorage
      saveProgress(newProgress)

      console.log(
        `‚úÖ Sucesso registrado: Pontos: ${newScore} (+${10 + additionalPoints}), Precis√£o: ${accuracy}%, Estrelas: ${stars}`
      )

      // Verificar se completou a atividade
      if (newSuccesses >= 5) {
        // Crit√©rio de conclus√£o: 5 sucessos
        setIsCompleted(true)
      }

      return newScore
    },
    [progress, saveProgress]
  )
  // Registrar erro
  const recordError = useCallback(() => {
    const newAttempts = progress.attempts + 1
    const accuracy =
      progress.successes > 0 ? Math.round((progress.successes / newAttempts) * 100) : 0

    let stars = 0
    if (accuracy >= 90) stars = 3
    else if (accuracy >= 70) stars = 2
    else if (accuracy >= 50) stars = 1

    const newProgress = {
      attempts: newAttempts,
      accuracy: accuracy,
      stars,
    }

    // Atualizar estado local imediatamente para reatividade da UI
    setProgress((prev) => ({
      ...prev,
      ...newProgress,
    }))

    // Salvar no banco/localStorage
    saveProgress(newProgress)

    console.log(
      `‚ùå Erro registrado: Tentativas: ${newAttempts}, Precis√£o: ${accuracy}%, Estrelas: ${stars}`
    )
  }, [progress, saveProgress])
  // Calcular tempo gasto (legacy - mantido para compatibilidade)
  const updateTimeSpent = useCallback(() => {
    if (startTime) {
      const timeSpent = Math.floor((Date.now() - startTime) / 1000)
      saveProgress({ timeSpent })
    }
  }, [startTime, saveProgress])

  // ======== SISTEMA DE RASTREAMENTO DE TEMPO AVAN√áADO ========

  // Iniciar sess√£o de atividade com tempo preciso
  const startActivity = useCallback(async () => {
    const now = Date.now()
    setActivityStartTime(now)
    setStartTime(now)
    setTotalPausedTime(0)
    setPauseStartTime(null)

    // Gerar ID √∫nico para a sess√£o
    const sessionId = `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
    setSessionId(sessionId)

    // Salvar in√≠cio da sess√£o no banco se poss√≠vel
    if (userId) {
      try {
        await databaseService.saveGameSession({
          user_id: userId,
          game_id: activityId,
          session_id: sessionId,
          start_time: new Date(now).toISOString(),
          status: 'started',
          difficulty: progress.difficulty || 'MEDIUM',
          score: 0,
          accuracy: 0,
          time_spent: 0,
          completed: false,
          correct_answers: 0,
          total_attempts: 0,
          data: {
            session_type: 'timed_activity',
            timing_enabled: true,
          },
        })

        console.log(`üïê Sess√£o iniciada: ${sessionId} √†s ${new Date(now).toLocaleTimeString()}`)
      } catch (error) {
        console.error('Erro ao salvar in√≠cio da sess√£o:', error)
      }
    }

    // Iniciar intervalo de atualiza√ß√£o de tempo
    const interval = setInterval(() => {
      updateCurrentTime()
    }, 1000) // Atualizar a cada segundo

    setTimeUpdateInterval(interval)

    return sessionId
  }, [userId, activityId, progress.difficulty])
  // Pausar atividade
  const pauseActivity = useCallback(() => {
    if (!activityStartTime) {
      console.warn('Tentativa de pausar atividade que n√£o foi iniciada')
      return
    }

    if (!pauseStartTime) {
      setPauseStartTime(Date.now())
      console.log(`‚è∏Ô∏è Atividade pausada √†s ${new Date().toLocaleTimeString()}`)

      // Parar o intervalo de atualiza√ß√£o
      if (timeUpdateInterval) {
        clearInterval(timeUpdateInterval)
        setTimeUpdateInterval(null)
      }
    }
  }, [pauseStartTime, timeUpdateInterval, activityStartTime])
  // Retomar atividade
  const resumeActivity = useCallback(() => {
    if (!activityStartTime) {
      console.warn('Tentativa de retomar atividade que n√£o foi iniciada')
      return
    }

    if (!pauseStartTime) {
      console.warn('Tentativa de retomar atividade que n√£o estava pausada')
      return
    }

    if (pauseStartTime) {
      const pauseDuration = Date.now() - pauseStartTime
      setTotalPausedTime((prev) => prev + pauseDuration)
      setPauseStartTime(null)

      console.log(`‚ñ∂Ô∏è Atividade retomada. Pausada por ${Math.floor(pauseDuration / 1000)}s`)

      // Reiniciar intervalo de atualiza√ß√£o
      const interval = setInterval(() => {
        updateCurrentTime()
      }, 1000)

      setTimeUpdateInterval(interval)
    }
  }, [pauseStartTime, activityStartTime]) // Finalizar atividade com m√©tricas detalhadas
  const finishActivity = useCallback(
    async (isCompleted = true, multisensoryData = null) => {
      // Se n√£o h√° activityStartTime, apenas limpar estados sem erro
      if (!activityStartTime) {
        // Silenciosamente limpar estados sem poluir console
        setActivityStartTime(null)
        setStartTime(null)
        setTotalPausedTime(0)
        setPauseStartTime(null)
        setSessionId(null)

        if (timeUpdateInterval) {
          clearInterval(timeUpdateInterval)
          setTimeUpdateInterval(null)
        }

        return {
          isActive: false,
          isPaused: false,
          totalTime: 0,
          activeTime: 0,
          pausedTime: 0,
          efficiency: 100,
          message: 'Nenhuma atividade ativa para finalizar',
        }
      }

      const endTime = Date.now()
      const totalTime = endTime - activityStartTime
      const activeTime = totalTime - totalPausedTime

      // Parar intervalos
      if (timeUpdateInterval) {
        clearInterval(timeUpdateInterval)
        setTimeUpdateInterval(null)
      }

      const timeMetrics = {
        sessionId,
        startTime: new Date(activityStartTime).toISOString(),
        endTime: new Date(endTime).toISOString(),
        totalTimeMs: totalTime,
        activeTimeMs: activeTime,
        pausedTimeMs: totalPausedTime,
        totalTimeSeconds: Math.floor(totalTime / 1000),
        activeTimeSeconds: Math.floor(activeTime / 1000),
        pausedTimeSeconds: Math.floor(totalPausedTime / 1000),
        efficiency: totalTime > 0 ? (activeTime / totalTime) * 100 : 100,
      }

      console.log('üèÅ Atividade finalizada:', timeMetrics)

      // Salvar dados finais no banco
      if (userId && sessionId) {
        try {
          const finalSessionData = {
            user_id: userId,
            game_id: activityId,
            session_id: sessionId,
            difficulty: progress.difficulty || 'MEDIUM',
            score: progress.score,
            accuracy:
              progress.attempts > 0
                ? Math.min(100, Math.round((progress.successes / progress.attempts) * 100))
                : 0,
            time_spent: timeMetrics.activeTimeSeconds,
            completed: isCompleted,
            correct_answers: progress.successes,
            total_attempts: progress.attempts,
            end_time: timeMetrics.endTime,
            status: 'completed',
            data: {
              ...timeMetrics,
              session_type: multisensoryData ? 'advanced_multisensory' : 'timed_activity',
              level: progress.level,
              stars: progress.stars,
              // Incluir dados multissensoriais no campo data (JSONB)
              ...(multisensoryData && { multisensoryData }),
            },
          }

          await databaseService.saveGameSession(finalSessionData)
          console.log(
            'üíæ Dados da sess√£o salvos com sucesso' +
              (multisensoryData ? ' (incluindo m√©tricas multissensoriais)' : '')
          )
        } catch (error) {
          console.error('Erro ao salvar dados finais da sess√£o:', error)
        }
      }

      // Reset dos estados de timing
      setActivityStartTime(null)
      setStartTime(null)
      setTotalPausedTime(0)
      setPauseStartTime(null)
      setSessionId(null)

      return timeMetrics
    },
    [
      activityStartTime,
      totalPausedTime,
      timeUpdateInterval,
      sessionId,
      userId,
      activityId,
      progress,
      isCompleted,
    ]
  )
  // Atualizar tempo atual
  const updateCurrentTime = useCallback(() => {
    if (!activityStartTime) {
      // Silenciosamente falha para n√£o poluir o console, j√° que √© chamado frequentemente
      return
    }

    if (activityStartTime && !pauseStartTime) {
      const currentTime = Date.now()
      const activeTime = currentTime - activityStartTime - totalPausedTime
      const activeTimeSeconds = Math.floor(activeTime / 1000)

      setProgress((prev) => ({
        ...prev,
        timeSpent: activeTimeSeconds,
      }))
    }
  }, [activityStartTime, pauseStartTime, totalPausedTime])
  // Obter m√©tricas de tempo em tempo real
  const getCurrentTimeMetrics = useCallback(() => {
    if (!activityStartTime) {
      return {
        isActive: false,
        isPaused: false,
        totalTime: 0,
        activeTime: 0,
        pausedTime: 0,
        efficiency: 100, // Valor padr√£o
        message: 'Atividade n√£o iniciada', // Mensagem informativa
      }
    }

    const currentTime = Date.now()
    const totalTime = currentTime - activityStartTime
    const activeTime =
      totalTime - totalPausedTime - (pauseStartTime ? currentTime - pauseStartTime : 0)
    const efficiency = totalTime > 0 ? Math.round((activeTime / totalTime) * 100) : 100

    return {
      isActive: true,
      isPaused: !!pauseStartTime,
      totalTime: Math.floor(totalTime / 1000),
      activeTime: Math.floor(activeTime / 1000),
      pausedTime: Math.floor(
        (totalPausedTime + (pauseStartTime ? currentTime - pauseStartTime : 0)) / 1000
      ),
      sessionId,
      efficiency: totalTime > 0 ? (activeTime / totalTime) * 100 : 100,
    }
  }, [activityStartTime, totalPausedTime, pauseStartTime, sessionId])

  // Cleanup ao desmontar componente
  useEffect(() => {
    return () => {
      if (timeUpdateInterval) {
        clearInterval(timeUpdateInterval)
      }
    }
  }, [timeUpdateInterval])
  // Resetar progresso da sess√£o atual (mantendo a pontua√ß√£o acumulada)
  const resetSession = useCallback(() => {
    setProgress((prev) => ({
      ...prev,
      // Mant√©m o score existente em vez de zerar
      attempts: 0,
      successes: 0,
      timeSpent: 0,
    }))
    setIsCompleted(false)
    setStartTime(Date.now())
    console.log('Sess√£o resetada, mantendo pontua√ß√£o acumulada:', progress.score)
  }, [progress.score])

  // Subir de n√≠vel
  const levelUp = useCallback(() => {
    const newLevel = progress.level + 1
    saveProgress({ level: newLevel })
  }, [progress.level, saveProgress])

  // Calcular estat√≠sticas
  const getStats = useCallback(() => {
    const accuracy = progress.attempts > 0 ? (progress.successes / progress.attempts) * 100 : 0
    const averageTime = progress.successes > 0 ? progress.timeSpent / progress.successes : 0

    return {
      accuracy: Math.round(accuracy),
      averageTime: Math.round(averageTime),
      totalGames: Math.floor(progress.successes / 5), // Cada 5 sucessos = 1 jogo completo
      bestStreak: calculateBestStreak(),
    }
  }, [progress])

  // Calcular melhor sequ√™ncia (implementa√ß√£o simplificada)
  const calculateBestStreak = useCallback(() => {
    // Para uma implementa√ß√£o mais robusta, seria necess√°rio armazenar o hist√≥rico de tentativas
    return Math.min(progress.successes, 10) // Simplificado
  }, [progress.successes])

  // Obter mensagem de encorajamento
  const getEncouragementMessage = useCallback(() => {
    const accuracy = progress.attempts > 0 ? (progress.successes / progress.attempts) * 100 : 0

    if (accuracy >= 90) return 'üåü Incr√≠vel! Voc√™ √© um g√™nio!'
    if (accuracy >= 70) return 'üéâ Muito bem! Continue assim!'
    if (accuracy >= 50) return 'üëç Bom trabalho! Est√° melhorando!'
    if (progress.attempts > 0) return 'üí™ Continue tentando! Voc√™ consegue!'
    return 'üöÄ Vamos come√ßar esta aventura!'
  }, [progress])
  // Resetar progresso
  const resetProgress = useCallback(() => {
    const initialProgress = {
      score: 0,
      attempts: 0,
      successes: 0,
      timeSpent: 0,
      level: 1,
      stars: 0,
    }
    setProgress(initialProgress)
    setStartTime(Date.now())
    setIsCompleted(false)
    console.log('Progresso resetado para valores iniciais')
  }, [activityId])

  return {
    // Estados b√°sicos
    progress,
    isCompleted,

    // Fun√ß√µes b√°sicas de progresso
    incrementAttempts,
    incrementSuccesses,
    completeActivity,
    updateScore,
    updateLevel,
    recordSuccess,
    recordError,
    updateTimeSpent,
    resetSession,
    levelUp,
    getStats,
    getEncouragementMessage,
    saveProgress,
    resetProgress,

    // ======== SISTEMA DE TIMING AVAN√áADO ========
    // Controle de sess√£o
    startActivity,
    pauseActivity,
    resumeActivity,
    finishActivity,

    // M√©tricas de tempo
    getCurrentTimeMetrics,

    // Estados de timing
    sessionId,
    activityStartTime,
    isActivityActive: !!activityStartTime,
    isActivityPaused: !!pauseStartTime,

    // Informa√ß√µes de tempo formatadas
    getFormattedTime: () => {
      const metrics = getCurrentTimeMetrics()
      return {
        active: formatTime(metrics.activeTime),
        total: formatTime(metrics.totalTime),
        paused: formatTime(metrics.pausedTime),
        efficiency: `${metrics.efficiency.toFixed(1)}%`,
      }
    },
  }
}

// Fun√ß√£o utilit√°ria para formatar tempo
const formatTime = (seconds) => {
  const hours = Math.floor(seconds / 3600)
  const minutes = Math.floor((seconds % 3600) / 60)
  const secs = seconds % 60

  if (hours > 0) {
    return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`
  } else if (minutes > 0) {
    return `${minutes}:${secs.toString().padStart(2, '0')}`
  } else {
    return `${secs}s`
  }
}

export default useProgress
